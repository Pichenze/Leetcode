题目：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1:
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5

示例 2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4

说明: 
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

思路：建一个大小为k的小顶堆，然后拿后面的n-k个元素，逐次与堆顶进行比较
      注意：堆顶元素在堆中是第k大的，所以如果比较的元素比堆顶元素小，说明该元素一定是小于第k大的元素的，不用考虑。
                                   相反，如果比较的元素比堆顶元素大，呢就说明堆顶的元素一定是小于第k大的元素的，将比较的元素与堆顶元素替换，并对堆进行调整
     在将后面的n-k个元素都遍历过后，堆顶的元素就是第K大的元素了。

知识点：
  用数组表示堆，索引0表示根节点，则对一个有双亲结点的结点且索引为i，它的双亲结点索引为（i-1）/2 (整数除法)
                              对一个有左右孩子结点且索引为i，它的左孩子结点索引为2*i+1,右孩子结点为2*i+2
  堆调整的两个方法：
    自底向上： 从堆中最后（最底层）的 内节点开始调整，直到根节点。
    自顶向上：从堆的根开始调整，直到堆中最后（最底层）的 内节点。
    
  建堆的过程：
    怎么运用两种堆调整方法快速建堆？ 目前想法：一次自底向上，可以得到准确的堆顶元素，然后进行多次自顶向下直到不需调整为止
    
  堆的调整包括插入，删除：
    插入：在堆的底层最左侧添加一个结点，相当于数组的长度加1。     之后的堆调整适合用自底向上调整的方法
    删除：去掉堆顶的结点，可以用堆在数组中索引的最后一个结点与其替换，并将堆大小减一1。  之后的堆调整适合用自顶向下的调整方法
